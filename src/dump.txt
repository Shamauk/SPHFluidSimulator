glUseProgram(rectangleShaderProgram);
drawRectangle(boundaryMin, boundaryMax, rectangleShaderProgram);
glUseProgram(shaderProgram);


    glUniform3fv(glGetUniformLocation(rectangleShaderProgram, "objectColor"), 1, glm::value_ptr(boundaryColor));


 const char* rectangleVertexShaderSrc = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;

        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;

        void main() {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
        }
    )";

    const char* rectangleFragmentShaderSrc = R"(
        #version 330 core
        out vec4 FragColor;

        uniform vec3 objectColor;

        void main() {
            FragColor = vec4(objectColor, 1.0);
        }
    )";

    GLuint rectangleShaderProgram = createShaderProgram(rectangleVertexShaderSrc, rectangleFragmentShaderSrc);
    glUseProgram(rectangleShaderProgram);

    // Set the model matrix for the rectangle
    glm::mat4 model = glm::mat4(1.0f);
    glUniformMatrix4fv(glGetUniformLocation(rectangleShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(model));
    glUniformMatrix4fv(glGetUniformLocation(rectangleShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(viewMatrix));
    glUniformMatrix4fv(glGetUniformLocation(rectangleShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projectionMatrix));



    // void drawRectangle(const glm::vec3& min, const glm::vec3& max, GLuint shaderProgram) {
//     float rectangleVertices[] = {
//         min.x, min.y, min.z,
//         min.x, max.y, min.z,
//         min.x, min.y, max.z,
//         min.x, max.y, max.z,
//         max.x, min.y, min.z,
//         max.x, max.y, min.z,
//     };

//     GLuint rectangleIndices[] = {
//         0, 3, 2,
//         0, 1, 3,
//         0, 4, 5,
//         0, 5, 1
//     };

//     // Create VAO, VBO, and EBO
//     GLuint VAO, VBO, EBO;
//     glGenVertexArrays(1, &VAO);
//     glGenBuffers(1, &VBO);
//     glGenBuffers(1, &EBO);

//     glBindVertexArray(VAO);
//     glBindBuffer(GL_ARRAY_BUFFER, VBO);
//     glBufferData(GL_ARRAY_BUFFER, sizeof(rectangleVertices), rectangleVertices, GL_STATIC_DRAW);

//     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
//     glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(rectangleIndices), rectangleIndices, GL_STATIC_DRAW);

//     glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
//     glEnableVertexAttribArray(0);

//     // Draw the rectangle
//     glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, 0);

//     // Clean up
//     glDeleteVertexArrays(1, &VAO);
//     glDeleteBuffers(1, &VBO);
//     glDeleteBuffers(1, &EBO);
// }
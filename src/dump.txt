glUseProgram(rectangleShaderProgram);
drawRectangle(boundaryMin, boundaryMax, rectangleShaderProgram);
glUseProgram(shaderProgram);


    glUniform3fv(glGetUniformLocation(rectangleShaderProgram, "objectColor"), 1, glm::value_ptr(boundaryColor));


 const char* rectangleVertexShaderSrc = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;

        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;

        void main() {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
        }
    )";

    const char* rectangleFragmentShaderSrc = R"(
        #version 330 core
        out vec4 FragColor;

        uniform vec3 objectColor;

        void main() {
            FragColor = vec4(objectColor, 1.0);
        }
    )";

    GLuint rectangleShaderProgram = createShaderProgram(rectangleVertexShaderSrc, rectangleFragmentShaderSrc);
    glUseProgram(rectangleShaderProgram);

    // Set the model matrix for the rectangle
    glm::mat4 model = glm::mat4(1.0f);
    glUniformMatrix4fv(glGetUniformLocation(rectangleShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(model));
    glUniformMatrix4fv(glGetUniformLocation(rectangleShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(viewMatrix));
    glUniformMatrix4fv(glGetUniformLocation(rectangleShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projectionMatrix));



    // void drawRectangle(const glm::vec3& min, const glm::vec3& max, GLuint shaderProgram) {
//     float rectangleVertices[] = {
//         min.x, min.y, min.z,
//         min.x, max.y, min.z,
//         min.x, min.y, max.z,
//         min.x, max.y, max.z,
//         max.x, min.y, min.z,
//         max.x, max.y, min.z,
//     };

//     GLuint rectangleIndices[] = {
//         0, 3, 2,
//         0, 1, 3,
//         0, 4, 5,
//         0, 5, 1
//     };

//     // Create VAO, VBO, and EBO
//     GLuint VAO, VBO, EBO;
//     glGenVertexArrays(1, &VAO);
//     glGenBuffers(1, &VBO);
//     glGenBuffers(1, &EBO);

//     glBindVertexArray(VAO);
//     glBindBuffer(GL_ARRAY_BUFFER, VBO);
//     glBufferData(GL_ARRAY_BUFFER, sizeof(rectangleVertices), rectangleVertices, GL_STATIC_DRAW);

//     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
//     glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(rectangleIndices), rectangleIndices, GL_STATIC_DRAW);

//     glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
//     glEnableVertexAttribArray(0);

//     // Draw the rectangle
//     glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, 0);

//     // Clean up
//     glDeleteVertexArrays(1, &VAO);
//     glDeleteBuffers(1, &VBO);
//     glDeleteBuffers(1, &EBO);
// }



// void FluidSimulator::setAllPressuresAndSetPressureForce() {
//     // First, calculate the pressure for all particles
//     for (Particle::Particle& particle : particles) {
//      //   std::cout << particle.density << std::endl;
//         particle.pressure = this->STIFFNESS * (particle.density - this->REST_DENSITY);
//     }

//     // Then, calculate the pressure force for all particles
//     for (Particle::Particle& particle : particles) {
//         glm::dvec3 pressureForce = glm::dvec3(0.0);
//         for (Particle::Particle* neighbor : particle.neighbors) {
//             glm::dvec3 r = particle.position - neighbor->position;
//             double lengthR = glm::length(r);
//             if (lengthR == 0) continue;
            
//             // Monaghan artificial pressure term
//             double epsilon = 0.01; // You can adjust this value (try values between 0.01 and 0.1)
//             double artificialPressure = -epsilon * VISCOSITY * (particle.mass / (particle.density * particle.density)) * (neighbor->mass / (neighbor->density * neighbor->density)) * (1.0 / (lengthR * lengthR));
            
//             pressureForce += (particle.mass * (particle.pressure / (particle.density * particle.density)) + neighbor->mass * (neighbor->pressure / (neighbor->density * neighbor->density))) * this->kernel.getKernelGradient(r) + artificialPressure * this->kernel.getKernelGradient(r);
//         }
//         particle.forceAccumulator = -pressureForce;
//     }
// }


    //enforceBoundaryConditionOnAllParticles();
void FluidSimulator::enforceBoundaryConditionOnAllParticles() {
    for (auto& particle : particles) {
        if (particle.position.x < minX) { particle.velocity.x = BOUNDARY_RESTITUTION * (minX - particle.position.x) / dt; particle.position.x = minX; }
        if (particle.position.x > maxX) { particle.velocity.x = BOUNDARY_RESTITUTION * (maxX - particle.position.x) / dt; particle.position.x = maxX; }
        if (particle.position.y < minY) { particle.velocity.y = BOUNDARY_RESTITUTION * (minY - particle.position.y) / dt; particle.position.y = minY; }
        if (particle.position.y > maxY) { particle.velocity.y = BOUNDARY_RESTITUTION * (maxY - particle.position.y) / dt; particle.position.y = maxY; }
        if (particle.position.z < minZ) { particle.velocity.z = BOUNDARY_RESTITUTION * (minZ - particle.position.z) / dt; particle.position.z = minZ; }
        if (particle.position.z > maxZ) { particle.velocity.z = BOUNDARY_RESTITUTION * (maxZ - particle.position.z) / dt; particle.position.z = maxZ; }
    }
}